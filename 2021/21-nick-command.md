Transcriber: Isaack

Intro

Hello everyone and welcome to our Data Umbrella webinar. This is our first webinar of 2021. I'm going to do a quick introduction and then Nick will do his talk and we'll open it up for Q&A. You can also ask questions in the question tab throughout the presentation and we'll sort of break whenever it's a good time to break; and this webinar is being recorded. Data Umbrella is an inclusive community for underrepresented persons in Data Science and we are volunteer-run. A brief couple of things about me; i'm a Statistician Data Scientist and I have an MS, Masters in Statistics and an MBA from NYU and I am the founder of Data Umbrella. um if you are interested in learning more about what i'm doing you can follow me on Twitter, LinkedIn or Github. I have the same handle @reshamas. We have a code of conduct here and we're really intentional about providing a respectful, welcoming, professional environment so please make sure that you follow our code of conduct - it's listed on our website and also this applies to the chat as well so please um you know, be professional about what we post on the chat. So the ways to support our community is most importantly as i said following our code of conduct. um we have a Discord channel - the link is on our website and so it's a great place to ask and answer questions there, if you want to share events through your community there that's a good place to do it and we have for all of our events we record them and we have a list of transcripts on our Github repo so if you would like to help us edit it um feel free to email us and I also have detailed instructions on how to go about doing that. Another way that you can support us is donate to our open collective. It helps us cover operational costs such as meetup dues and other other operational costs and we greatly appreciate your support. We are on all social media platforms as Data Umbrella so the best place to find out about upcoming events is on our Meetup group. All of our events are posted as I said on the video library on Data Umbrella we have a job board as well and a newsletter which goes out once a month and we have resources on our website related to: diversity, allyship, inclusive language and more. On our video library on Youtube we have a playlist for contributing to open-source and so we have um for the library is: Numpy, scikitlearn, pandas and Core Python. There are some videos so you know, for those of us in Data Science open source is critical and it's a good way to figure out and learn how you can contribute. We also have a playlist on career advice. We have three speakers who've done really informative talks about it so if you are looking for career advice please check those out. This is just um a small screenshot of some of the events that we have on our Youtube so check it out depending on what topic you're interested in. Our job board is `jobs.dataumbrella.org`, if your company is hiring they can post jobs there and we can share it with our community on um in our newsletter as well as in upcoming webinars. Our highlighted job that we have is um Cloud Infrastructure Engineer at Coiled and it is a Distributed Infrastructure, so feel free to check that out to learn more about the position. This is just a list of some of the resources that we have on our website: Open-source, guides to using inclusive language, how people can be allies, how to handle burnout and resources for AI ethics. As I mentioned before we're on all platforms under Data Umbrella so depending on your choice whichever platform you prefer to use um follow us on that platform. I want to share some upcoming events that we have we have: Intro to Sphinx for Python Documentation presented by Melissa Weber and that is on January 28th and the link to that to sign up is on our Meetup page. We have our flagship event for the year which is a scikit-learn open-source sprint. This sprint is focused on getting participants from the regions of Africa and Middle East and so if you're in those regions please check out our website it's `afme2021.dataumbrella.org`. If you have any questions, feel free to email us. The information about contacting us is on the application form on the website. There's also, want to share a community event that's coming up which is Global Diversity CFP day and the goal of this event is to provide resources for underrepresented or marginalized groups in tech to submit CFPs and get started speaking at meetup events and conferences and there are live streams. There are six different live streams for different regions in the world and there's some great talks and workshops coming out. The website is `globaldiversitycfpday.com` um feel free to check that out. I want to now introduce our speaker for this event; it is Nick Janetakis and Nick is a Developer and sysadmin. He is an independent freelancer, course creator and hosts the podcast: Running in Production. He has hundreds of blog posts and Youtube videos focused on building and deploying web apps um as along with development environment tips. um I reached out to Nick because you know studying using the command line is a really really useful um skill for Data Scientists and I think it's really going to be beneficial to people in our community whether they're aspiring Data Scientists or experienced practicing Data Scientist and you can find Nick and more information on Nick's website `nickjanetakis.com` and Github is `@nickjj` and Nick is also on twitter as `@nickjanetakis` and with that i am going to turn the camera and microphone over to Nick.


Creating a Command Line Driven Dev Environment(7:15)

Okay thank you for the introduction let me uh just share my screen really quick. Do you see anything? It shows your slides by the way just a heads up. Here we go okay so everyone can see this now I hope. So hey everyone, thanks a lot for coming my name is Nick Janetakis and today we're going to go over creating a command line driven development environment. By the end of this talk you'll be well on your way to having a tricked out terminal along with being familiar with tools like tmux and Vim and also being comfy using command line tools to solve real world problems. We're also going to go over how you can manage your dotfiles. These are files that typically live in your home directory and are responsible for configuring a bunch of command line tools. Just a heads up, everything we go over today is going to work on all major distros of Linux, macOS and Windows 10. In the case of Windows, it will be expected that you're using WSL1 or WSL2 which is the Windows Subsystem for Linux. That's because we're going to focus on shell-scripting in a Unix or Unix-like environment, not so much Powershell. Also, we're going to cover a lot of ground in this talk but don't worry i'm not going to leave you hanging on installing and configuring everything on your own from scratch. So feel free to check out this Git repo afterwards `https://github.com/nickjj/nyhackr-cli-dev-env`. It has a very skimmable reference for everything we're going to do uh as well as this slide deck you can just download it there as well. With that said let me quickly introduce myself; my name is Nick Janetakis and i've been a freelance developer for the last 20-ish years and I would say for the last seven or so years i've been doing a lot of DevOps work that's mainly setting up Linux servers, working with various cloud hosting providers, deploying code, writing shell-scripts and using tools like Docker, Ansible and Terraform. Now the specifics aren't too important but i do think working with a bunch of different technologies and projects has led me to having a command line focused development environment. Now chances are you're not going to be using the same exact tech stack as me but we can all use the same command line tools to solve our unique problems. For example, i found myself bouncing around so many different freelance and open-source projects and i wanted a way to quickly switch between them to get right back into our project as if i never left. That led me to discovering tmux and eventually Vim and by the way if you decide you don't want to use Vim as a primary code editor that's completely fine. I only started using Vim about two years ago mainly because the combination of using it with tmux really let me quickly switch between projects on the command line but even if you don't use Vim, there's so much more to the command line than code editing and tmux is really useful on its own in any case. Now, before we dive into the basics of using tmux and other tools let me quickly go over a couple of practical examples of how i use tmux, Vim and various command line tools in my day to day. I'm going to blaze through this without explaining everything in detail so you can get a high-level overview of how everything fits together and see what types of workflows you can create. This way you can start thinking about how all of this applies back to your dev environment. Then after that we'll go back and cover how everything works and how everything can be configured in more detail. Also, just a heads up for the sake of time and avoiding silly mistakes like typos I decided to go with animated gifs for demo-ing a few things - that means you'll occasionally see animations that are looping indefinitely and they may not line up exactly with what i'm saying but i think you'll get the gist of it. Lastly, feel free to ask questions if anything isn't clear because I am prepared to jump into a live terminal if needed. Let's do this. So here's a brand new terminal that I just opened and let's say i want to start working on the source code to my Flask course which is a web application running in Docker. I was working on that last night but today is a new day. Instead of opening everything from scratch, I can attach to a tmux session that's running in the background. It already has Vim open with the last file I was editing along with the entire app running inside of Docker - it's like I never left. I can immediately get back into the thick of it. Next up, let's say I want to do a project-wide search for all the tests in the project, I can do a search for the test_string in Vim and it'll do a fuzzy search and list all the matches. Also instead of a string I could have used a regular expression. After that Vim will present me a way to filter and select the matches I want and it even shows a little preview of the file as I cycle through the matches. My font size is massive for the sake of this talk but normally you can see a lot more of the file in the preview. Then from here I can pick a file and it opens in the main buffer. If i want to look at multiple files at once, Vim makes it easy to open horizontal and vertical splits. It looks a little cramped here because the font size is so large. With my normal setup, I can fit four 80 character-width files side by side on a 2560x1440 monitor running at 1:1 scaling. Also, I didn't show it there but it's really easy to switch between the different splits using hotkeys or the mouse. Now let's say that you want to open a different set of files but you don't want to lose your existing layout of files. With Vim, you can open files in a new tab and this tab becomes a bucket to hold as many files as you want. Then you can switch between tabs up top using hotkeys or the mouse. So, let's say we did some work and now it's time to commit our changes. I can hop over to the second tmux window on the bottom, open a split and make my `git commit` message. As an aside, tmux also supports horizontal and vertical splits. I also like using Vim for writing commit messages because it helps me adhere to best practices such as warning me through syntax highlighting if the first line is too long or if i have any typos. Next up, let's say you have a few tmux splits open and you really want to view the log details in full size but you don't want to close your existing splits. tmux lets you zoom in and out of any split you want. I'm just hitting a hotkey there to toggle the zoom in and out. Also it's worth mentioning you can do the same thing with Vim splits too. I didn't show it for the sake of time and just as a reminder we're going to see how to do all these things later on when we dive into the details. Next up, let's say I want to jump to a completely different tmux session. In this case, it's my podcast site and maybe i came here to add a reference link or something like that. After doing whatever i needed to do, I can jump over to the second tmux window on the bottom and deploy the site with Ansible. Ansible's deploy command is kind of long and I don't want to have to hit the up arrow 100 times to find it, so I can reverse-search my history using the same tool that we saw in Vim to fuzzy search through files in a project. This tool is called fzf by the way. Lastly here's a quick demo of doing Github style markdown previews in Vim. Technically it's not real time since it's not updated on every character press but you can turn that option on if you want; I keep it off for performance reasons - instead it updates every time I switch Vim modes or save the file. Also on the right Vim puts aaron's exclamation points near the line count. That's to let me know that these lines have changed based on the most recent `git commit`. It'll show new lines and deleted lines with different markers too. Honestly, we could spend the whole hour looking at Vim and tmux features but there's so much more to the command line than using Vim, so let's switch gears and go over a few practical examples of using command line tools. For example, let's say that i'm working on something and it sparks an idea for a blog post. I can just run a custom script I created called drafts and start typing whatever I want after running that command. It automatically creates a date-labeled file in my personal website's drafts folder. If I rerun the same script it opens the file in Vim so I can start fleshing out the draft right now. That's typically what happens in practice. This might seem like such a minor thing but it really helps remove friction when starting new blog posts because the tool I use to build the blog expects files to be in this dated format. Not having to create this file manually means it's one less thing I need to think about. As for the draft script it's a simple script and don't worry if you can't read the text. The real takeaway here is the command line is there to help you solve whatever unique problems you have. It's almost like a direct link to your brain except you just have to type what you want instead of just thinking it, for now. In another example, I created a script to toggle dark and light mode for my terminal, tmux, Vim and other tools. I prefer using light themes in my day to day but after running a poll I found most folks like seeing a dark theme in my video tutorials, so with the script, I can quickly change between the two. It's open source in my public dotfiles and we'll take a look at that later. In one more example, let's say I was heading over to new york city later tonight and i wasn't sure if I needed a really heavy jacket because I live 90 minutes away and weather is crazy like that. Not a problem - I can just run `weather nyc` and that's what we see here. There's almost a tool for everything. In this case the weather command is a very simple function I set up to `curl wttr.in` which is a website that shows you the weather in a browser but it's also optimized for displaying the weather on the command line. There's also dozens of general-purpose Unix tools that you can use to solve problems around processing and filtering text. I'm trying to keep this talk focused on workflows and more generally your development environment, but besides using tmux and Vim, piping together a few unix commands and writing your own scripts to solve your specific problems is a huge part of using the command line. It becomes another tool at your disposal. With that said, let's take a couple of minutes and go over one example of doing this. So imagine if you have a csv file with a bunch of transactions in it and you want to extract that information like how much money you generated but also have an ability to filter the results on specific product names, date ranges and so on. The csv file we're looking at here is a simplified version of a csv that my course platform spits out with a bit of anonymized data in practice. You'll find payment gateways like stripe and paypal supplying your transaction information in csv files, so this is a real-world use case. As an aside, Vim has a plugin to help view and display csv data and we'll go over that in a little bit but viewing this data isn't super useful. Typically, I want to figure out things like how many courses were sold this month and have an ability to filter the results by course name and so on and that begins with removing the csv headers. `sed` stands for Stream Editor and in practice it's a very useful tool for doing a find and replace in text, but in this case we're using it to delete the first line in the file. The 1d part stands for delete the first line. If we swapped out the one with a two then the first two lines would have been deleted instead. One neat thing about the command line is there's often more than one way to do something. If you googled around for how to delete the first line in a file, you'll find all sorts of different answers and most of them will probably work. For example, we could have used the `tail` command and passed in these flags to get the same exact result. Technically `tail` is faster than `sed` on Linux but it's also slower on macOS by default. At least according to Stack Overflow although I find the `tail` version to be less readable for this type of use case. It's confusing because plus one actually outputs the entire file so we need to offset what we want by one and then there's also differences between using one and plus one. One takeaway here is you should be mindful of performance, but readability almost always wins especially if the performance difference isn't worth anything considering. For example, if we had thousands of rows and the `sed` version finished in five milliseconds but the `tail` version finished in 3 milliseconds, it doesn't really matter for a script that I run once a month on my dev box, but i will remember what 1d does instead 3 months from now which has way more value in the end. As an aside, `tail` is still a great tool. If we wanted to get the last line or last couple of lines of the file, then `tail` is for sure the way to go here. You can even have `tail` watch a file for changes in real time and output new lines as they come in. That could be really useful for monitoring web server logs but moving on we're going to use the `sed` version and the next thing we'll want to do is filter out a specific column of data. This column is the net amount of cents and it's the thing we want to sum up in the end. Unix was invented a long time ago but they made some great design decisions such as being able to pipe the output of one program as input into another and you'll also find that text streams are the protocol that most Unix commands use. That means most command line tools expect text as input and produce text as output. This is remarkably powerful because suddenly it means you can combine hundreds of tools in a number of different ways to solve very specific problems that you might have - and unix pipes are the secret sauce that lets us send the output of one program as input to another. Pipes are defined with the vertical line and you can see that they are sitting in between `sed` and `cut`. That means in this case the output of the `sed` command is now being fed in as input to the `cut` command and this `cut` command is going to delimit the output by a comma since this is a csv file and we want to grab the fifth column which is the net amount in cents. If we ever wanted to calculate the transaction fees for a specific payment gateway then we can change this five to a four and now it would get the previous column which are those fees and this is why command line tools are amazing. We get to break down the problem into bite-sized chunks and then work on only a very specific tiny problem at hand. I think this fits the functional programming model very nicely. Speaking of which, a lot of functional programming languages also have the idea of a pipe operator where you can send the output of a function as input to another function. It's a great way to break up a problem. Next up, now that we have a list of amounts we'll want to sum them up, but before we can sum them we need to transform the list of numbers into a math equation that adds each value. For that there's the paste command and don't ask me why it's name paste because I have no idea. It has nothing to do with your clipboard - all I know is when we use these flags it becomes what we see here. If you wanted to do something else like subtract the values, then you can replace the plus at the end with a hyphen and technically you can use this paste tool for anything - it's not limited to math. If we put an underscore instead then it would delimit them with that. By the way the `-d` is the delimiter and `-s` puts everything onto one line and now that we have our equation ready to go we can use the basic calculator command aka the `bc` command to sum them all up and there we go. We solved our problem by piping together a few commands. In practice when you're more familiar with these commands you can create pipelines like this in a few minutes. By the way there's a gotcha here too with the `bc` command. If you ever want to support floating point numbers you'll need to add the `-l` to it. I didn't add it here since we're dealing with summing whole numbers, so there's never going to be a decimal point. Next up, let's filter the results by a specific course by using the `grep` tool. This is a tool you'll likely find yourself using all the time. You can, provided a text stream or a file and then we can match whatever search string we want. In our case it's a regular expression that makes sure `,bsawf` is at the very end of the line. This is nice because it means we no longer need to use the `sed` command to chop out the first line since this `grep` pattern will only ever match csv rows that have this specific text and then from here we can use what we did before to sum up the net sales and suddenly we have the total sales for a specific course. I also decided to throw in two more examples here at the end: the first one lets us count the number of sales for a specific month Here we just take the output of what `grep` produces and pipe it into the `wc` command - the `-l` flag counts the number of lines instead of words. Alternatively grep has a `-c` flag to get a count of the results instead of returning each match on a new line. In practice, I would use this second command if I wanted the count. It's less typing, less overhead and more straightforward to read. So that's a mini crash course in combining a couple of commands together to solve a real world problem. The cool thing is, if you find yourself writing scripts like this and they start to get a bit unwieldy then you can put them into a dedicated script file and run them like that. We'll talk more about shell-scripts a bit later on.






Picking a terminal and shell(23:44)

And that leads us into the next part of this talk. We just covered a bunch of practical workflows and examples of using the command line. Now, it's time to get into the details about setting up your development environment and that begins with picking a terminal and configuring your shell. We're going to spend quite a bit of time on this because it's pretty core to your environment. The interesting thing about tmux by the way is it gives you tabs splits and a way to search up and down a buffer in any terminal. This allows us to pick a terminal that focuses on speed and having the least amount of input latency when you press keys. You can also optimize for quality of life enhancements too, like customizable hotkeys, easily being able to zoom in and out, being able to click urls and also have solid unicode support for displaying icons and emojis. If you're going to be spending a lot of time typing something in the command line, it should feel really good and make you happy while doing it. For example i'm using Windows and the Microsoft terminal has really really low key press latency. It's like night and day compared to most other terminals on windows. I tried a whole bunch and the other one that came close was wsltty but i've gone with the Microsoft terminal because it's more integrated with being able to easily switch between wsl distros. As for anyone running native Linux, xterm is a very lightweight terminal and that's pretty much the lowest input latency that i've ever encountered on any OS. Also with a bit of configuration, it hits all the marks for the quality of life improvements. I do run native linux on a modified chromebook and that always amazes me at how nice the terminal experience is. For macOS to be honest, I am not 100% sure since I have no first hand experience but i've heard really good things about iTerm2, so I might want to start there if you want to give it a shot. In addition to that, there's cross-platform terminals like Alacritty, which is something you may want to check out too but personally on Windows and Linux, i've always used the Microsoft terminal and xterm and I think the takeaway here is it doesn't matter too much on which terminal you pick because tmux brings a lot to the table. So just stack up on speed and quality of life improvements and I wouldn't worry about too much about having native terminal support for things like tabs splits and searching. Next up it's time to pick a shell and your shell provides a command line interface to your operating system. It's both interactive and it can be used as a scripting language. Right now I happen to be running bash and you can check which shell you're currently running by running `echo $0`. There's also `echo $SHELL` too but this is technically the default shell for your system or user, not your current shell. To help clarify that another shell is `sh` which is the Bourne shell and it was released way back in 1979. If you're curious its successor bash stands for the born again shell and that was released about 10 years later in 1989 but just because i'm running bash here doesn't mean I can't use the original Bourne shell. You can run it by running `sh`. Notice how the prompt changed and now running `echo $0` returns sh instead of bash but `$SHELL` still returns bash because for my `nick` user on the system bash is set as the default. Typically in modern systems you wouldn't use `sh` as your interactive shell in your day-to-day. It's missing very nice to have features like being able to tab complete commands or use the arrow keys to move the cursor around. However, when writing shell scripts it's often a good idea to target your scripts for the shell since it's the most compatible across systems although there's not too much harm in targeting bash too because it's available on most Linux systems and macOS. We'll talk about shell-scripting in a bit, but for now let's focus on the shells themselves. Besides sh and bash there's also newer shells such as z shell which is labeled as zsh. Just like bash extended the original Bourne shell, z shell extends bash. Personally i'm not a huge fan of it but it's not because it's bad or I have anything against it. I'm just content with bash and I don't really feel like i'm missing out on anything at the moment. By the way it's worth pointing out if you're running a modern version of macOS if you’ve followed along before and you ran the `echo $0` command, chances are you saw z shell as your shell. That's because macOS made it the default shell in the Catalina release back in 2019, but even so bash is still available to be run on macOS. Next up, there's fish which is an even more recent shell and it stands for Friendly Interactive Shell. Unlike z shell, fish is not compatible with sh or bash because the creators thought certain design decisions from back in the day were poorly designed so they went their own way. Honestly this shell isn't for me mainly due to that lack of compatibility but it might be okay for you. It has a lot of the out of the box features like auto-suggestions but you can also get that to work with other shells too. It just takes a bit more effort. With that said, at least now you know these options exist. We only have so much time here so we can't spend a ton of time breaking down the pros and cons of each shell but overall, your shell is there to make it a pleasant experience to use your system from the command line. If you're curious now you can Google for things like bash versus z shell versus fish and you can make an informed decision. Just be aware that this is an excellent topic to get lost in yak shaving or bike shedding. In other words, you can spend a lot of time here and not wind up with a lot of gains. The real gains come from learning how to create tools that help you solve your exact problems and getting comfy with workflows that let you do whatever you need to do quickly. It's not a life or death decision either. You can always switch your shell later on without too much fuss. So that's a basic rundown of shells. Since I happen to use bash let's go over how I  have it configured. Although in a lot of cases, even if you plan to use z shell or fish, most of what we're about to cover still applies. Most shells have a few config files in your home directory. With bash you'll have at least the `.bashrc` file and maybe a `bash_profile` too. In my case, I decided to rename my bash_profile to profile so that it'll work with any shell. Although technically this profile file has one line in it that's specific to bash so it's not entirely portable across all shells. With that said, let's take a look at this file. Just a heads up before we get into this, i'm only going to be showing a few lines at a time so it's easier to talk about. This entire file along with all of my config files are in my dotfiles repo on Github and we'll cover that near the end. As for this profile file it runs once when you log into your system, so it's a good spot to put things that don't change very often. For example, I modify my path here so that any executable scripts or binaries that exist in my home directories `.local/bin` directory are available to run without supplying the entire path. That's how I ran that draft script from before. It exists in my `.local/bin` directory and I can run it like any other command that's already on my system path like `grep`, `ls` and some other commands that we took a look at before. This is also where I like to set system defaults for certain tools that I use. The editor variable controls which text editor to open. For example if a tool needs to open a text editor, it opens Vim by default due to this being set. The editor variable is a standard, so a bunch of tools know how to read from it. We saw that before when I wrote a `git commit` message get new to open Vim due to this setting. You can also choose to set your own variables here if you want. I really really like this pattern because it means your settings are stored in one spot. You know if 10 different tools decided to open your default text editor it means you only need to change this variable in one spot if you wanted to use something else. Next up there's a bunch of configuration to use syntax highlighting in certain tools like `less` and `man`. The `man` command opens a reference manual for many different tools. For example if you run `man grep` it'll open the manual for `grep`. This is a good way to learn about a specific tool. You can also see their syntax highlighting without setting those environment variables we just saw. This would be all one solid color, which in my opinion is a bit harder to read. Lastly this line: `cat ~/.profile` does the `$0` trick we did before to see what shell we're running and even if we're running bash and we have the `.bashrc` file present, it sources that file. Sourcing it basically means running the script and any shell-related changes will take effect in your current shell. If you are running a z-shell or fish you would want to modify this for whatever shell you're using. Next up let's take a look at the `.bashrc` file for the sake of time. I'm going to try to keep things brief rather than go into the gory details of everything. This file executes every time you start a new terminal session. That means every time you open a new terminal window or spawn a new tmux window this `.bashrc` file is going to run top to bottom. The first five settings control your history. Basically if you want to save the last 50,000 lines of history ensure each line has its own time stamp, avoid adding duplicate or empty lines and also append to the history file instead of rewriting a new file on every entry. Your history is saved in your home directory with bash. It'll be in a `.bash_history` file. Mine is nearly empty now because prior to this talk I backed up my real history file so that I didn't have to worry about showing sensitive information during the talk. Some of them contain client information about client work and I didn't want to leak those out by accident. Speaking of history you can take a look at your history by running the `history` command. That's useful to find commands you've run in the past and with saving 50,000 entries chances are you'll be able to find commands you've run months ago but dropping through this output would be kind of painful so bash provides the `ctrl+r` keyboard shortcut to reverse search your bash history. We'll go over that in more detail once we encounter a different part of this `.bashrc` file. The next couple of settings are default values of the `.bashrc` file. It's not worth spending any time on them but I included them here anyways although it is worth mentioning that on a Linux system you can check out what the default `.bashrc` file is by catting out etc skel .bashrc -> `cat /etc/skel/.bashrc/`. That could come in handy if you're tweaking your `.bashrc` file and you want to double check the default value. Also in the `skel` directory there's a few other default config files to look at if you're curious. Next up we have aliases and these are really really useful. The basic idea here is if an aliases file exists then we load it in. There's two files here because my dotfiles are public on Github and I wanted the option to have a local aliases file that's ignored from version control. This `.local` file contains aliases that are only ever going to be useful to me and are super specific to private files on my file system like quickly accessing client project and things like that. With that said let's take a look at the regular aliases file which by the way in bash would be named `.bash_aliases` by default. I decided to go with aliases to make it a bit more portable across different shells. It still works as aliases because it's tied into the file being sourced from the `.bashrc` file we just looked at. Technically we can name this file anything we want as long as it matches up with what you source. The first couple of aliases are defined by default. It's mainly for enabling colors in popular commands like `ls` and `grep` but it also sets up popular aliases like `ll`. I use this one all the time to list directories and files. My real aliases file has over 20 different functions and aliases and we could legit spend the next two hours going over it but instead I want to focus on the big picture here. In my aliases file you'll notice there's both functions and aliases and they both allow you to access your function or alias as if it were a script on your system path. If you plan to pass in arguments like you see here then it would make sense to use a function; otherwise you can set up an alias. For example, with the `weather` command we can pass in a city, zip code or nothing and it all works the same. the `$1` ends up being the value you passed in. If it's empty then it's treated as an empty string, but in this case, we have an alias that takes no arguments and we saw this command being run during the demo. Instead of just running the script on its own, it also sources the `.bashrc` file because it ends up changing the color of a specific tool that depends on bash being reloaded. That's kind of a neat trick because the alias and script both have the same name. In this case the alias takes precedence over the script's path. The takeaway here is don't be afraid to create aliases that help you in your day-to-day. You should try to mold your dev environment to fit your exact needs. I think there's really a whole mindset or philosophy around that, especially when it comes to using Linux. With the amount of configuration you can do it really becomes an OS that you can customize for you. One day i'll switch to native linux and the only reason I haven't already is because I had some audio trouble with some of my hardware. I bet if I were running native linux for the last 10 years I would probably have 500 aliases and custom scripts to help me in my day-to-day. Anyways, that is it for aliases.The next part of my `.bashrc` file is related to the prompt and we haven't really gone over that yet. So let's quickly do that before we see how it's configured. My prompt doesn't look like the bridge of the USS enterprise and this really comes down to personal preference. I very much prefer a minimal prompt that gets out of my way and lets me focus on the commands i'm running and the output of those commands, but I do like to see some information in my prompt for example as we saw earlier if you're in a Git repo it will show the branch name which I find to be quite handy. Beyond that I also like to see the current directory of where I am since that's important information as well. Also if I ssh into one of my production servers, I like to configure the prompt there to be read to remind myself that I probably shouldn't copy paste commands from the internet here or start running a bunch of commands without thinking. I don't drink much but if I did, seeing this red prompt would be a last resort reminder to hopefully prevent myself from deleting a production database in a drunken rage. One takeaway here is all of these command line tools are super configurable. If you don't like my basic prompt and you'd rather have a more busy prompt with emojis, rainbows and seeing your battery life or hard drive space on every line that's totally cool and you can do that. I've linked to a few resources in the Git repo on projects that help you customize your prompt in different ways. With that said let's see how to configure your prompt AKA your ps1 which stands for primary prompt string. The syntax looks like total insanity and it kinda is but there is a silver lining. Once you have it set up, you never have to worry about it again until you get bored and want to change things around. We can spend an hour here easy but let's go after the low hanging fruit. The bash provides a bunch of special characters such as `\u` and `\h`. These are special variables that translate to specific things. In the case of `\u`, that's your username and `\h` is the host of the machine. In my case my username is `nick` and I named my computer `kitt`. If you're old enough to remember Knight Rider you'll get that reference. There's also this `\w`, hidden amongst a sea of backslashes. That's the current working directory which is `\temp` in this case. There's a number of other special variables that you can use too and a lot of them are related to dates and times and i've dropped a link to the bash manual in the references if you want to check that out. Now, besides those special variables most of the other characters in this ps1 are related to outputting color. These are called ANSI escape codes and it's kind of where the insanity begins. It's not that it's a terrible system, it's just that it requires a lot of escaping and also resetting colors back to the default color if you've picked a different color. That's why you see a few `00` entries. That's the reset code. As for picking colors if you Google around for an ANSI color chart, you'll find a bunch of examples. I usually go to Wikipedia for it but that has too much to show in one slide so I made a more readable chart. Here we can see a list of valid colors. `fg` is foreground and `bg` is background. If you remember my username and host was green so that would be foreground color 32 and if you go back to the previous slide here we can see 32 being set for the username and host. We can also see that 34 are set for the working directory which is blue, that's the `\temp` and if we jump back to the chart again here we can see that 34 is blue. Now there is a variation of these colors called bright mode. As far as I know there's more than one way to set them. Honestly a lot of this stuff is black magic to me and I just copy paste things and tweak it until i'm happy but as for bright mode, notice how there is a `01` before the 32 and 34. To my knowledge that flips on bright mode for the color being set. If you set it to `00` it would be the regular version of the color. An alternative way to set that is to add 60 to the value so 32 becomes 92 and 34 becomes 94. Keep in mind not all terminals and themes are created equal so you may see different results depending on what you use but here's a modified chart to show how bright colors look using xterm with the default theme. Also my prompt only modifies the foreground color of text but you can set the background color too. I'm going to leave that one up to you if you want to research it. You'll be able to find lots of copy-pastable examples if you Google around. As for the command separator it's pretty standard to end your prompt with a dollar sign. This will end up being the character that separates your prompt with whatever command you're running. Some folks like to use unicode characters or an emoji. Years ago i used a lightning bolt but eventually grew bored of it but don't let me talk you out of using something else. I really do encourage you to mold your prompt and dev environment to whatever you like. If you did want to swap out the dollar sign it's a matter of replacing it here at the end. As for this prompt the last component is getting the Git branch wedged in near the end. The basic idea is we execute a function here and the output of that function ends up in its place. That function is defined in the middle here and all it does is grab the current branch then it uses `sed` to replace some characters that Git usually outputs when you want to run the `git branch` command. Also if the command fails, we redirect all errors to `dev null` which means if we're not in a  Git repo we end up with no output which is exactly what we want. Honestly it's not too important to go through this function in detail. I'm pretty sure I grabbed it from Stack Overflow like seven years ago and it still works great. There's other more fancy Git integrations that you can add too such as outputting specific characters depending on the state of staged files or if a file is different than what's been commit but in practice I don't really find that to be that useful. Typically that information could be obtained in your code editor or using Git commands when you're ready to commit something but the branch is very nice to see because being on the wrong branch can cause all sorts of confusion and typically you're launching Vim or another text editor while you're actively looking at your prompt so the branch is nice to see there. Okay so that's the prompt. The next bit here updates your terminals window title depending on which directory you're in. This only works if your terminal supports it and it's part of the default `.bashrc` file so it's not super important to go over. Next up we have `asdf`, which is a tool that helps you manage programming language versions in a consistent way. It's not important to cover now since this mainly relates to installing specific programming languages although the Vim plugin I use for previewing markdown files does require having Node installed and I do use asdf to install Node. We'll talk more about this later. Next up there's `fcf` which is a command line fuzzy finder. We saw this in action during the demo when searching through a project in Vim as well as the command history. This tool replaces the behavior for reverse searching your history and makes it a lot better searching. Your history is an important part of using the command line so let's spend a minute or two going over how to do this and how fcf improves the experience. When you hit `ctrl+r` in bash without fcf you'll get a menu that looks like this. The basic idea is you can start typing the first few characters of any command and it'll start showing you matching commands you've run in the past. In this case i'm searching for the characters `bs`. If there's multiple commands that start with these characters then you can cycle through them by hitting `ctrl+r` as many times as you want. It's called a reverse search because it returns the last command that matches. In other words it searches your history in reverse. This is one of the most useful things ever. It sure beats hitting the up arrow 42 times in a row to find some command you ran three days ago. I probably use this feature 100 times a day. You can pick the command you want to run by hitting enter and it'll populate the command for you. So in the above case all I did was hit `ctrl+r`, searched for the `bs` characters and then hit Enter. All in all something like this takes a second or two to use. It's really practical - by the way you can also cancel your reverse search by hitting `ctrl+c`, if you don't want to pick anything. Now when you use fcf, `ctrl+r` is still available to run except now it looks like this. Then as you start typing it narrows down the search in real time. In this case only commands that contain the `c` character are returned. It's also a fuzzy search, meaning if instead I searched for the `l` character it would have found the second match since `clear` has an `l` in it. It ranks them based on what it thinks is the best match and it's very good. I would say probably 99% of the time it picks the command they want after typing a few characters and that's even going through thousands of files. In the one percent case where it fails it's no biggie I just type one or two more characters and it always finds it after hitting enter. To pick the item it'll inject the command into your prompt and then you can choose to run it. You can also hit `ctrl+c` to cancel the selection just like the regular `ctrl+r`. fcf can do a lot more than search your history too. You can use it to search your process list and more. To be honest it deserves its own 45 minute talk. It's a really really useful tool but now that we know how to search our history efficiently let's go back to the `.bashrc` file. We saw these lines a few minutes ago. This controls enabling and configuring fcf. The bottom line enables fcf and the two optional lines above it configure it. fcf supports both dark and light themes and you can also customize the colors however you see fit but the line above that is a bit more interesting to talk about. It configures fcf to use a tool called ripgrep instead of the `grep` tool when it searches for matches. ripgrep is a much faster version of grep although in practice I do use `grep` on the command line because it's fast enough but fuzzy searching is pretty demanding and I find ripgrep speed boost to be worth it. It narrows down search results pretty much as fast as you can type even with thousands of files. This is important because the Vim plugin for fcf will use ripgrep when searching for files to open or searching your project for specific text. During the demo I ran the `rg` command which uses ripgrep under the hood and fed the results into fcf using a Vim plugin. Installing ripgrep is easy because every major Operating System has a version of it in its package manager but I recommend holding off on installing it right now because there's a couple of other tools covered in my .bashrc file that we'll want to install and it's going to be a lot easier to install them after we talk about dotfiles since that's all documented in one spot and finally there's a bit of configuration in my .bashrc file related to WSL2 and WSL1. This mainly sets up an xserver display so you can share your clipboard or run graphical apps between WSL and regular windows. I don't want to spend a ton of time on this one but if you're using WSL, the reference has a link to a video that goes over this in more detail. So that's how I have bash configured. I know it was a lot to take in but we just condensed multiple months of research in about 10 minutes or however long that took. Now before we get into using tmux, I do want to cover one last thing that's important when writing your own scripts. When writing shell scripts you might have seen something like what we see here. This is called a shebang and it's the first line in the file that starts with pound, exclamation point followed by a path to some type of binary such as sh, bash or any programming runtime that can be called from the command line. You may have also seen this style of a shebang which technically works on most systems but it's considered to be less portable. It's less portable because the bash binary might not exist in `/bin` on some systems whereas `usr/bin/env` exists almost everywhere. I tend to use this style unless I made a mistake and use the less portable version by accident. Speaking of portability, remember when we talked about using sh instead of bash for scripting, well the barn shell aka sh is POSIX compliant. This is a standard that was created to ensure compatibility between different Operating Systems. To write a POSIX compliant shell script you would reference sh instead of bash. In practice I try to do that but sometimes you really need the extra features provided by bash in which case i would use bash without giving it a second thought. Honestly we could spend two hours going over the subtle differences between the two so let's just leave it at that. You can always Google for the differences later. With that said I think one of the best ways to learn something is to see fully working examples so i've dropped a bunch of links in the references to a number of scripts i've open sourced over the years to help me in my day-to-day. Now i'm not saying it's the best code ever written but it might get your noodle cooking to see what types of programs or problems you can solve on the command line. All of the code is MIT licensed too. So that's shells and scripting in a nutshell. On that note we covered a lot, but don't feel compelled to learn everything upfront before you do anything. You can slowly introduce things on a need to know basis. What I mean by that is like any programming language or environment you can still be very productive without understanding the entire language and ecosystem in detail.


Using tmux(49:45)

Next up let's go over using tmux. Unlike the shell we'll spend the majority of our time using tmux instead of configuring it but we will take a look at some config settings too. First up, what is tmux? Good question, i'm glad you asked. tmux is a terminal multiplexer and what that means is it lets you create and control multiple terminals from a single screen. We saw that before in the demo when creating windows and splits. It also lets you create sessions that you can attach and detach from which is amazing because it means if you close your terminal everything will still be running in the background and you can connect to it or connect to any session at any time and it'll just resume where you left off before. You'll find tmux in whatever package manager your Operating System uses so it's going to be no problem to install it but like before let's not worry about installing it until we talk about dotfiles near the end. For now let's just focus on using it. One core feature of tmux is its ability to control most things with hotkeys but don't worry you can usually use the mouse for a lot of things too like selecting text or copying text or clicking different windows or split panes but since tmux is so high key driven they introduce the idea of a thing called a prefix key - the basic idea is you'll hit this key along with some other key afterwards to perform a specific action. This helps namespace all of your tmux hotkeys so you don't end up overriding hotkeys from other tools. By the way I also tend to call this a leader key because that's what Vim defines it as so you may hear me use both terms interchangeably. By default it's bound to `ctrl+b` which in my opinion is a bit funky to hit so i've remapped my prefix key to be the backtick that's usually under the escape key or to the left of the one on a standard keyboard. In practice you'll find a lot of folks use this key - it's pretty easy to access and you really type it in your day to day and when you do need to insert a backtick somewhere then you can just hit the key twice. It's not really a big deal. Throughout the rest of this section i'll always reference hotkeys with the word prefix instead of using the backtick directly since you could in theory be using a different key. By default when you open a terminal tmux is not going to be running. We need to run it manually by running the tmux command. After running it you'll know you're inside of tmux because you'll see a status bar on the bottom of your terminal. Out of the box the status bar is going to look different than what we see here but we'll go over how to configure that a bit later on. I made mine pretty minimal to maximize usable space while giving me just enough information I care about. From here we have access to a bunch of tmux goodies. For example, if you hit `prefix+c` you can create a new window. Notice on the bottom, we have two windows now instead of one and both of them are named bash because that's the shell i'm running. So let's say we opened a couple of windows like we see here and it starts to get confusing because we're not sure what's running in each window. Well if you hit `prefix+comma` tmux will bring up its command mode and now we can rename the window by typing in whatever we want with a new name. You can also switch to a different window by hitting leader 2 or whatever number you want to switch to. The window you're currently looking at will have a star next to it which makes it easy to identify at a glance. By default, tmux will order windows starting at zero but in my tmux config I changed it to start at one because in my opinion it's a lot easier to hit ``+1` rather than ``+0`. Also if you have mouse mode enabled you can click any one of those windows on the bottom to switch it and yep I do have mouse mode enabled in my config. Can everyone read that? yeah just kidding. So as an aside i'm not trying to cover every tmux feature here there's other ways to switch between windows too but i'm trying to focus on what you might use in your day-to-day. tmux has this help menu that you can bring up with `prefix+?` to learn all about its different binds and that's kind of what we see here. The funny thing is I zoomed out to try to fit all of this in one screenshot but there's still five lines above this. There's also the man pages too and plenty of cheat sheets available if you Google around. With that said, I included a link to a cheat sheet if you want to check that out in the references. So going back to our example before, if you want to split a window in half you can use `prefix+b` to open a split below you but that's not the default bind. Instead I made it match the same bindings as my vim config and there's really no limit to how many times you can split a window. You're basically limited by your monitor screen resolution. In practice I use split panes all the time and you can switch between them using the mouse or if you use my tmux config you can also use `alt and the up or down arrow` depending on which direction you want to go. Alternatively you can also split your windows vertically this time around you can use `prefix+v` which also matches my Vim keys binds or Vim key bindings. Also while i'm not showing it here, you can combine horizontal and vertical splits together however you see fit. You can even drag the bar around with your mouse to resize the panes. There's resize hotkeys for that too but personally I don't even know what they are off the top of my head because I just don't use them at all. Next up if you do find yourself having a bunch of splits open but you want to temporarily zoom into one of them without closing the rest of your splits then you can do that with `prefix+z`. You can tell if you're zoomed in because it'll show a `z` next to the window name on the bottom. This is something I do all the time as well. It's especially handy if you're creating tutorial videos with a large font size and you just want to zoom into something to explain one window but I still do use this in my day to day with a regular font size too. Now there's a lot more we can do with windows and panes but this goes back to the 80-20 rule which is basically focusing on the 80% which is going to give you the most benefits versus how much time you spend. In other words what we just covered goes a really really long ways for dealing with windows and split panes. Next up let's go over another killer feature of tmux which are sessions. If you hit `prefix+d`, that is going to detach you from your current session. We didn't go over this yet but when we ran tmux before it started a session for us behind the scenes and it named that session zero since we didn't define a name. That means if we close our terminal we could reattach to it and things will be back as if we never left. If we ever forget what's running we can also use the tmux `ls` command to get a list of sessions. In our case we have just the one here. Then if we run the `attach` command along with a specific session name, we can attach to a specific session. Right now our session is named zero but we can choose to rename it to something else which we'll do in a few. It's also worth pointing out that if you run `tmux attach` with no arguments it'll attach you to the last used session which is something I do all the time. After running that attach command we're back to our session from before and it's like we never left. What's really useful is that you can have multiple sessions running at once and switch between them at will. That's a game changer if you have a terminal focused development environment. Speaking of multiple sessions, if you're already in a tmux session, you can create a new session by running `prefix+:` to bring up command mode and then you can run the new session command. I'm passing in a custom session name of cool here but you can name it whatever you want. Technically you can make a new session without naming it but I find in practice that naming your sessions is totally worth it, especially when you're dealing with a few sessions. As for this animation, right after the session is created we can see that we're put into a new session with only one window but our old session is still running in the background. Also if you're curious, most commands that you can run in command mode can also be run directly on the command line although in this case if you try to create a new session like this when already in a session, tmux is going to prevent you from doing it by default; otherwise it gets too confusing with nested sessions. However, when you run `tmux new-session` in command mode that doesn't nest the new session with an existing session. It creates a completely new one. I know that's a little confusing but that's how it works as far as I know. The takeaway here is you should always spawn new sessions from command mode if you're already inside a session or you can just detach from your current session and make a new session from the command line. As for switching between sessions you can hit `prefix+s`. This gives you a list of all of your sessions and then you can use the arrow keys to pick the one that you want and switch to it by hitting enter. Upon doing so you'll be put into that session immediately. What's really cool is as you cycle through the list of sessions you'll get to see a preview of what's running in the lower half of the window. That could be very handy to see what's running in a session - you can even click directly into one of those boxes and jump straight into that session’s window. Next up, let's say you want to search up and down your buffer. With the way I have things configured, you can use the mouse wheel to scroll up in your buffer and that puts you into tmux's copy mode. You can identify that by the orange label in the top right which shows the number of lines in the buffer. Then you can hit the `/` key to begin searching, type in your term and hit enter. From here tmux will highlight all the matches and you can press `mn` as a nick to jump to the next match or `shift+n` to go in reverse. This is what I meant by tmux supercharging your terminal. Suddenly we can do all of this with any terminal. Now with the way I have things configured, if you select any text with the mouse and let go with the mouse button, it'll copy that text to your clipboard. That's due to using a tmux plugin called yank. You can even use the mouse wheel or the page or up down keys to quickly select a bunch of text that is multiple pages long. Copy pasting text is a pretty common thing to do so i'm sure you'll be using that one once in a while, I know I do. Next up it's worth pointing out that if you open two separate terminals you can connect both of them to the same session. When you do this your actions are going to be mirrored in both terminals. That includes both typing and switching windows. By default tmux will also resize the viewport of both terminals to be whatever the smaller one is. To be honest I am not sure why it does this by default but you can change this behavior. For example if you attach to the session like this, along with setting one config option, then you can connect to the same session but each terminal will have its own independent view of a specific window. This is very very handy if you use multiple monitors. It means you can have a second terminal open on your other monitor and look at a different window on the same session that's running on your main monitor. I do this quite often when i'm working on projects that require seeing many things at once. Lastly let's say you're detached from tmux and you want to stop all of your sessions. You can do that by running `tmux kill-server`. That's going to completely kill tmux, destroy all of your sessions and stop any processes that were running in the foreground inside of tmux. That could be handy if you get busy with not naming your sessions and after a few weeks of using tmux without rebooting you wind up with having 20 unnamed sessions and 50 copies of Vim running - been there done that. Although, as for rebooting, by default you will lose all of your sessions after your reboot. On Linux this might not be too bad because you know you might not reboot for six months but on Windows this is painful because Windows will reboot your machine whenever it feels like it but there is a silver lining. There's a plugin called tmux resurrect that will let you save and restore your sessions after a reboot even if the tmux server is killed. With that said let's quickly go over a few interesting parts of my tmux config. For the sake of time, we're not going to spend as much time as we did going over the shell related configs. My config is pretty well commented so it should be fairly easy for you to take a look at it in more detail on your own. Like the other config files will show a little bit at a time and this is how you can customize your prefix key. There's not much to it. If you wanted to use something other than the backtick then you would change it here. Next up, this one is super interesting. This is the setting that allows you to get independent windows when connecting to the same session multiple times. Apparently resizing isn't enough. You need to aggressively resize to get your independence. These settings control the status bar. I explicitly removed everything except showing the window number and labels. By default tmux shows a clock on the bottom right side of the status bar. I have that disabled with comments. If you Google around for tmux status
bar configuration you'll find a bunch of examples on what you can do. For example, you can add things like your network IP address and more. That could be handy if you're connecting to multiple remote machines. These settings work together to make tmux a bit more human friendly. For example, if you had four windows and you closed window 2, then tmux by default will leave a numbered gap. What I mean by that is you would end up with windows 1, 3 and 4 being available. The first setting removes the gaps so you would end up with windows 1, 2 and 3. The other settings on the bottom make tmux start numbering windows at 1 instead of 0. Next up, you can quickly reload your tmux config by hitting `prefix+r`. That's handy to do if you're tweaking your tmux config and you want to see the changes without having to kill your tmux server. This is similar to sourcing your `.bashrc` file to see the changes without opening a new terminal. Lastly, tmux has plugins and the tool to manage them is called tpm. That stands for tmux plugin manager in case you're wondering. It's something you'll need to install and it's included in my dotfiles documentation. The yank plugin copies selected text to your clipboard and the resurrect plugin lets you save and restore tmux sessions even if your tmux server dies. You can do that by hitting `prefix+ctrl+s` to save your sessions and `prefix+ctrl+r` to restore them once you're inside any existing tmux session and that's all you have to do. This plugin is awesome especially if you're on Windows. Now let's talk a little bit about Vim and unlike the tmux session this is going to be more like a rapid-fire description of a bunch of Vim plugins that I use in my day-to-day. That's because to really really really get into Vim would totally require its own dedicated talk instead of a few minutes. If you're curious, I do have over 15 videos on Youtube covering a bunch of Vim topics. I've linked to them in the reference notes. Lastly I do run regular Vim not neovim but all the plugins that we're about to go over will work with Vim 8.1 or above and neovim as well. Speaking of plugins, we'll need to install a tool to use them. Then Vim has many many different choices for how to install plugins since it's been around for so long. The one I use is called plug and you'll see how to install it once we get into the dotfiles section. None of these plugins are in any specific order but let's start with the ones that we've seen during this talk. Also the code snippets you see here are straight from my Vim config file. As for fcf it allows us to fuzzy search files, git commits and more. It's one of my favorite plugins. fern allows you to quickly visualize your project's directory structure and it makes it really easy to rename, copy or delete files and directories. It even supports bulk renaming files and even buffer for doing complex renaming. This could come in really handy if you want to reorganize how you label media files or whatever you might be doing. Next up, signify is a super efficient plugin for displaying Git changes like what we saw during the markdown preview demo. That's where we saw the orange exclamation point. It also uses a green plus symbol for new lines and a red dash for deleted lines. Then for previewing markdown I use this plugin it's labeled as being for neovim but it still works with the vim 8.1 or above. This is the plugin that requires having Node installed. Also we saw this plugin display markdown that looks like Github styles but you can very easily change that by swapping a css file in case you happen to be using Gitlab, Bitbucket or you just want your markdown style differently. For csv files, there's not much to say about this one other than it works really well. By the way I have about 20 other plugins related to syntax highlighting for all the different tools and languages they use on a regular basis. That's one of the reasons why I really like Vim. It lets me use the same tool for everything. Multi-snips and Vim snippets really help with providing shortcuts for inserting code. Most editors have some type of snippet support and these work really nicely in Vim. As for this other plugin it tells Vim to automatically pop up its code complete window while you type. Now if you've ever used Sublime Text that makes it very similar to how you can autocomplete anything you've typed in any open buffer. The cool thing about this one is none of these plugins require running a language server if you happen to know what that is. This is more for a lightweight approach to get useful but not hyper-intelligent autocomplete that's context aware. Moving on, this one lets you zoom in and out of splits in Vim just like you can with tmux. This comes in very handy if you're someone who likes to open a bunch of splits. Now all of these plugins work together to serve the end goal of making it easier for you to find, search and replace text. I use these all the time especially the visual star and vim grepper plugins. There's a 30 minute video linked in the references that goes over how to do various find and replace workflows in Vim. It ranges from searching for a character in one line to doing a regular expression based find and replace across multiple files. Lastly there's two themes that I really enjoy using. Both of them have very good syntax highlighting for many popular languages including Python and R. I used one dark for all the screenshots in this talk and I typically use it when recording videos and then I switch over to one light for personal use. Prior to that I used Gruvbox for almost two years and I still really like that theme but like most developers we get bored of themes over time, so I like to mix it up but I could see myself switching back to it in the future. Besides plugins related to syntax highlighting, there's still about 15 or so plugins that I didn't mention which are still worth using for very specific things. Now I don't quite have 200 plugins but I would say I have about 45 or 50 and I do use them on a regular basis. I'm very protective of which plugins I add and I also focus on keeping things as efficient as possible. That means not using plugins that introduce typing delays or other hitches. With that said, all the plugins I use are listed in my `.vimrc` file in my dotfiles with a one line comment explaining which each one does and that's going to wrap things up for Vim. So now let's talk a little bit about dotfiles. We've already seen a few such as the profile `.bashrc` file and tmux config files. When it comes to configuring user settings for command line tools, it is very common to put them into various dotfiles. It's not a guaranteed rule, but most command line tools will use files that begin with a dot for its configuration and there's three main places where they might exist. Some tools will write out their config files into your user's home directory which is what we saw before with a `.bashrc` file, tmux config and a few others. It's also quite popular for tools to create a dot directory in your home directory named after that tool. For example, if we take a look at my home directory there's a few tools that do that. This usually happens when a tool has one or more config files but not always. Sometimes a tool will place a bunch of config files unrelated to its configuration along with its configuration all in one spot. It's also pretty popular for tools to place their config files within their own directory within the `.config` directory inside of your home directory. That's a lot of directories. This is a newer standard based on something called the xdg-based directory specification, which is linked to in the reference notes if you want to learn more about conventions around where certain files should live and that's what we can see here. If I happen to write any scripts that need one or more config files, I always use the config directory since it's a standard. So that's how configuration is mainly handled but I sort of simplified where I store my individual dot files to make the previous slides easier to read. In reality most of my dot files are symlinked to a separate directory that's contained within a Git repo. You can see that here with the arrow pointer which is a symlink. Symlinks are references to another file or directory. You can sort of think of them as shortcuts if you're coming from the Windows world. Now they're not specific to dot files but they're often used together with that file so that you can save your dotfiles in one centralized location and then symlink them to wherever they need to go in your home directory and that leads us into one way of managing your dotfiles. I'm a fan of having a single directory somewhere on my system such as this dotfiles repo in my Github folder and then I can symlink the config files to where they need to go. This keeps things simple and it makes it easy to replicate my setup on another machine or share it with others. All you would have to do is clone down this repo and then set up the symlinks if all you wanted to do is replicate my configs but symlinks are not the only way to manage your dotfiles. There's dozens of tools focused on dotfiles management, but honestly I never felt the need to go that far. A really popular one is called Yet Another Dotfiles Manager and i've dropped a link to that one in the references. It's basically an abstraction on top of Git and it comes with its own custom command line tool to manage your dotfiles. If you find yourself gravitating towards wanting to use a dotfiles manager, I would start with this one. I haven't used it personally but I do know someone who is happily using it. That someone has been working on the command line for 15 plus years and he looked at a lot of other tools so I trust his recommendation. With that said let's take a look at a few key parts of my dotfiles repo on Github. In addition to the config files themselves, I included screenshots and documentation related to installing the tools I use on a few popular Linux distros and macOS. There's not really an unwritten rule to include installation instructions in your dotfiles repo but I decided to go the extra mile. I included them mainly because I have a few programming courses and I wanted a single place where I could point folks to in case they wanted to replicate or cherry pick a few things for my setup. For example, if you wanted to install tmux, Vim and a number of other tools, you could copy paste one of the package installation commands depending on what OS you're using. In this case it's the Debian and Ubuntu installation instructions but in the readme file there's copy pasteable commands for brew in case you're using macOS. You can also choose to add or remove anything you see fit. For example, `jq` is a command line tool that lets you parse json. If you don't care about that then you can easily remove it. Then for installing the dotfiles themselves, it's a matter of cloning this repo and then setting up the symlinks. You could choose to grab all of my configs or just the ones that you care about. For example, if you find yourself using z shell instead of bash you could remove my `.bashrc` file or if you're not using WSL you can remove the last symlink since that only applies to WSL. Also if you want more control over your setup and want a very personalized solution, you could always skim through my individual configs and copy paste whatever you want directly into your config files. Beyond that there's a bunch of commands like this where you can pick and choose to install whatever tools you want. This is quite a bit more than what's shown here but the rest are documented in the same way and all of these commands will work on Linux and macOS since it's mainly running `curl`, `git` and `pip` commands. There's even reminders like this in the readme file for installing plugins for Vim and tmux. There's also a section up top to help verify everything is set up correctly. Lastly it's worth mentioning that these dotfiles are going to evolve over time. In the references i've linked to the exact commits for all the files that we went over but I do recommend checking out the master branch on your own because if you're watching this talk in the future chances are i've updated a number of things which are probably improvements in some way or another. So that's the TLDR on dotfiles. If you Google around for dotfiles Github you'll find thousands of other examples. I'm not sure how many of them will have tons of documentation but at least now you're familiar with the concept and that's kind of the main takeaway of this talk. I tried my best to showcase and go over a bunch of tools but ultimately it's up to you to apply as much or as little as you want in your daily workflow, like anything that takes time to build up muscle memory. Especially for hitting hotkeys that might be foreign to you. I know it took me a long time to get used to them and I still feel like I have a lot to learn. In other words don't get discouraged if you struggle for a while. It definitely gets better over time and on that note hopefully at the very least a couple of unknown unknowns were discovered today. Usually when I watch a talk or read a book i'm hoping to walk away with at least one nugget of information then I can apply it back to my day-to-day and that is all I have. Thanks a lot for having me and if anyone is still awake and we still have some time i'm more than happy to answer any questions. Cue awkward silence. Not really sure what I need to do beyond this point. 


Outro(1:14:55)

Oh can you hear me now? Okay if anybody has any questions uh please feel free to post um in the chat or in the Q&A. um I want to thank Nick for his presentation um yeah that was um a lot of great information. um I did have a question for you um there are a number of different um these are called Vim is called the terminal editor right um there's a number of different ones um what are your thoughts on um some of the other ones? Okay by the way this is a little bit weird you're actually coming through on headphones sitting on my desk instead of the one in my ear so i can barely barely hear you but i'm pretty sure you asked me like how to compare different terminal emulators like what's the difference between using next term and alacrity or kitty or like 50 other ones uh it really comes down to preference right. Like tmux really helps you out when it comes to using different features like splitting windows and panes and searching. So i just try to really go for the terminal that is basically the fastest and the ones listed in that other slide were kind of the ones that I prefer but you can always just Google around for you know like alacritty versus kitty versus hyper or whatever terminal that you want and check out its features. Okay, great um somebody asked is asking a question on check can we review the video? um If you're referring to this video, yes I will post it pretty soon on the Data Umbrella um Youtube. Sorry to interrupt this is crazy like I can't hear you at all. So i'm going to switch over to different headphones. Okay yeah these are also uh a lot uglier and bigger. I use these to edit my videos but they work very nicely. Can you hear me now? Yeah much better. Okay um all right um yeah so reviewing the video the video will be posted um pretty soon um and we'll send an announcement um somebody else says I really enjoyed learning about tmux as an unknown unknown. Thanks for the informative talk yes and actually um you know I for tmux I wrote up a um i have like a written up thing that I did when I was taking the fastai deep learning um best day deep learning course and so I can share that as well um but yeah tmux is very very um it's really really useful i'd say yeah yeah it's one of those tools where it's like until you realize that it exists like how to live live my life without that yeah it is I mean i'm gonna let me just see if i can find it pretty quickly um it was it certainly was very um very popular yeah if anybody has any other questions feel free to ask now while Nick is available um and um yeah yeah do you remember one question that popped up last time was like well let's say I don't want to use Vim like let's say I want to use VScode instead like is the command line still useful and like totally for sure like VScode if you wanted to jump between different projects you can totally do that as a built-in terminal like you know the real takeaway is uh just using the command line in general right it's not tied to specifically using Vim right okay that's great um and i guess the other thing is maybe this is a good time to share your um Youtube channel. Do you want to share that in the link Nick ah I don't even have that chat open i can't even bring it up otherwise it's going to like interfere with some things here but I can search uh Youtube is it yeah right if you just search for my name it's there well I hope there might be other Nick Janetakis out there but no it's true you have 10 and a half thousand subscribers is that right? Okay do you have a custom url for your Youtube uh funny enough i don't remember it but i'm pretty sure it's just `youtube.com/nickjanetakis`. okay alright cool also if you went to my home page here then it's in the about page on the bottom. ah okay cool yeah there's a lot of a lot of helpful stuff there okay so um if there are no other questions I am going to uh we're going to uh complete the webinar. um once again thank you so much um return no problem yeah also one heads up about that Youtube channel there is a Vim and tmux playlist so if all you care about is that then I would check that out ah wonderful cool alright thank you yeah no problem.
